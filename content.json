{"pages":[],"posts":[{"title":"django模版与过滤器","text":"12345678910111213141516171819202122&lt;div class=\"cart\"&gt; &lt;Header/&gt; &lt;div class=\"cart-info\"&gt; &lt;h3 class=\"cart-top\"&gt;购物车结算 &lt;span&gt;共{{course_list.length}}门课程&lt;/span&gt;&lt;/h3&gt; &lt;div class=\"cart-title\"&gt; &lt;el-row&gt; &lt;el-col :span=\"2\"&gt;&amp;nbsp;&lt;/el-col&gt; &lt;el-col :span=\"10\"&gt;课程&lt;/el-col&gt; &lt;el-col :span=\"8\"&gt;有效期&lt;/el-col&gt; &lt;el-col :span=\"4\"&gt;价格&lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt; &lt;div class=\"cart-item\"&gt; &lt;el-row :key=\"key\" v-for=\"course,key in course_list\"&gt; &lt;el-col :span=\"2\" class=\"checkbox\"&gt;&amp;nbsp;&amp;nbsp;&lt;/el-col&gt; &lt;el-col :span=\"10\" class=\"course-info\"&gt; &lt;img :src=\"$settings.Host+course.course_img\" alt=\"\"&gt; &lt;span class=\"course-title\"&gt;{{course.name}}&lt;br&gt;{{course.discount_name}}&lt;/span&gt; &lt;/el-col&gt; &lt;el-col :span=\"8\"&gt;&lt;span&gt;{{course.expire}}&lt;/span&gt;&lt;/el-col&gt; &lt;el-col :span=\"4\" class=\"course-price\"&gt;¥{{course.discount_price}}&lt;br&gt;&lt;span&gt;原价 ¥{{course.price.toFixed(2)}}&lt;/span&gt;&lt;/el-col&gt; &lt;/el-row&gt;","link":"/2019/07/09/aa/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/01/04/hello-world/"},{"title":"数据分析","text":"什么是数据分析 是把隐藏在一些看似杂乱无章的数据背后的信息提炼出来，总结出所研究对象的内在规律 数据分析是用适当的方法对收集来的大量数据进行分析，帮助人们做出判断，以便采取适当的行动 商品采购量的多少 总部向各个地区代理的发货量 …… 数据分析实现流程 提出问题 准备数据 分析数据 获得结论 成果可视化 数据分析三剑客 numpy pandas matplotlib numpy模块：一维或者是多维的数组（低版本的列表） NumPy(Numerical Python) 是 Python 语言中做科学计算的基础库。重在于数值计算，也是大部分Python科学计算库的基础，多用于在大型、多维数组上执行的数值运算。 numpy的创建 使用np.array()创建 使用plt创建 使用np的routines函数创建 使用array()创建一个一维数组 123import numpy as nparr = np.array([1,2,3,4,5,6])arr array([1, 2, 3, 4, 5, 6]) 使用array()创建一个多维数组 1np.array([[1,2,3,4],[5,6,7,8],[9,9,9,9]]) array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 9, 9, 9]]) 数组和列表的区别是什么？ 数据中存储的数组元素的数据类型必须是统一 数据类型是有优先级： str&gt;float&gt;int 12arr = np.array([1,2.2,3,4,5,6])arr array([1. , 2.2, 3. , 4. , 5. , 6. ]) 将外部的一张图片读取加载到numpy数组中，然后尝试改变数组元素的数值查看对原始图片的影响 123import matplotlib.pyplot as pltimg_arr = plt.imread('./assets/1.jpg')plt.imshow(img_arr) &lt;matplotlib.image.AxesImage at 0x16e9faebb70&gt; 1plt.imshow(img_arr-100) &lt;matplotlib.image.AxesImage at 0x16eb3240dd8&gt; zeros() ones() linespace() arange() random系列 1np.zeros((3,4)) array([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]])1np.linspace(0,100,num=20) array([ 0. , 5.26315789, 10.52631579, 15.78947368, 21.05263158, 26.31578947, 31.57894737, 36.84210526, 42.10526316, 47.36842105, 52.63157895, 57.89473684, 63.15789474, 68.42105263, 73.68421053, 78.94736842, 84.21052632, 89.47368421, 94.73684211, 100. ])1np.arange(0,100,step=3) array([ 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99])1np.random.randint(0,100,size=(5,6)) array([[71, 76, 47, 11, 7, 6], [47, 89, 70, 44, 41, 96], [58, 42, 36, 53, 49, 55], [13, 32, 64, 58, 15, 7], [78, 56, 40, 71, 45, 63]])1np.random.random((3,4)) array([[0.24913375, 0.91988476, 0.36386714, 0.58404557], [0.15544885, 0.73892461, 0.82189615, 0.80368295], [0.07230386, 0.45535116, 0.75370029, 0.03377829]]) 随机性： 随机因子：x(时间) 123#固定随机性np.random.seed(10)np.random.randint(0,100,size=(5,6)) array([[ 9, 15, 64, 28, 89, 93], [29, 8, 73, 0, 40, 36], [16, 11, 54, 88, 62, 33], [72, 78, 49, 51, 54, 77], [69, 13, 25, 13, 92, 86]])numpy的常用属性 shape ndim size dtype 12345img_arr.shapeimg_arr.ndimimg_arr.sizeimg_arr.dtypetype(img_arr) numpy.ndarray1arr = np.array([1,2,3],dtype='uint8') numpy的数据类型 array(dtype=?):可以设定数据类型 arr.dtype = ‘?’:可以修改数据类型 1arr = np.array([1,2,3]) 1arr.dtype = 'int32' numpy的索引和切片操作（重点） 索引操作和列表同理 12arr = np.random.randint(0,100,size=(6,8))arr array([[30, 30, 89, 12, 65, 31, 57, 36], [27, 18, 93, 77, 22, 23, 94, 11], [28, 74, 88, 9, 15, 18, 80, 71], [88, 11, 17, 46, 7, 75, 28, 33], [84, 96, 88, 44, 5, 4, 71, 88], [88, 50, 54, 34, 15, 77, 88, 15]])1arr[1] array([27, 18, 93, 77, 22, 23, 94, 11]) 切片操作 切出前两列数据 切出前两行数据 切出前两行的前两列的数据 数组数据翻转 练习：将一张图片上下左右进行翻转操作 练习：将图片进行指定区域的裁剪 1arr.shape (6, 8)12#切出前两行arr[0:2] array([[30, 30, 89, 12, 65, 31, 57, 36], [27, 18, 93, 77, 22, 23, 94, 11]])12#切出前两列arr[hang,lie]arr[:,0:2] array([[30, 30], [27, 18], [28, 74], [88, 11], [84, 96], [88, 50]])12#切出前两行的前两列的数据arr[0:2,0:2] array([[30, 30], [27, 18]])12#数组数据翻转plt.imshow(img_arr) &lt;matplotlib.image.AxesImage at 0x16eb30833c8&gt; 1img_arr.shape #前两个维度表示的是像素，最后一个维度表示颜色 (426, 640, 3)12#将图片进行上下翻转plt.imshow(img_arr[::-1,:,:]) &lt;matplotlib.image.AxesImage at 0x16eb30de828&gt; 1plt.imshow(img_arr[:,::-1,:]) &lt;matplotlib.image.AxesImage at 0x16eb313b8d0&gt; 1plt.imshow(img_arr[::-1,::-1,::-1]) &lt;matplotlib.image.AxesImage at 0x16eb3198a58&gt; 12#裁剪plt.imshow(img_arr) &lt;matplotlib.image.AxesImage at 0x16eb31f8898&gt; 1plt.imshow(img_arr[50:450,300:750,:]) &lt;matplotlib.image.AxesImage at 0x16eb5164470&gt; 切片汇总： 切行：arr[index1:index3] 切列：arr[行切片,列切片] 翻转：arr[::-1] 变形reshape 变形前和变形后对应的数组元素个数是一致 12arr = np.array([1,2,3,4,5,6])arr array([1, 2, 3, 4, 5, 6])12#将一维数组变形成二维arr.reshape((2,3)) array([[1, 2, 3], [4, 5, 6]])1arr.reshape((-1,2)) array([[1, 2], [3, 4], [5, 6]])级联操作：concatenate 是对numpy数组进行横向或者纵向的拼接 axis轴向的理解 0:列 1：行 12arr1 = np.array([[1,2,3],[4,5,6]])arr1 array([[1, 2, 3], [4, 5, 6]])1np.concatenate((arr1,arr1),axis=1) array([[1, 2, 3, 1, 2, 3], [4, 5, 6, 4, 5, 6]])12arr2 = np.array([[1,2,3,3],[4,5,6,6]])arr2 array([[1, 2, 3, 3], [4, 5, 6, 6]]) 匹配级联 级联的多个数组的形状是一样 不匹配级联 级联的多个数组的形状是不一样（维度必须一样） 多个数组的行数一样进行行级联 多个数组的列数一样进行列级联 12#讲arr1和arr2进行级联np.concatenate((arr1,arr2),axis=1) array([[1, 2, 3, 1, 2, 3, 3], [4, 5, 6, 4, 5, 6, 6]])常用的聚合操作 sum,max,min,mean 12arr = np.random.randint(0,10,size=(4,5))arr array([[6, 6, 5, 6, 0], [0, 6, 9, 1, 8], [9, 1, 2, 8, 9], [9, 5, 0, 2, 7]])1arr.sum(axis=1) array([23, 24, 29, 23])常用的数学函数 NumPy 提供了标准的三角函数：sin()、cos()、tan() numpy.around(a,decimals) 函数返回指定数字的四舍五入值。 参数说明： a: 数组 decimals: 舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置 1np.sin(arr) array([[-0.2794155 , -0.2794155 , -0.95892427, -0.2794155 , 0. ], [ 0. , -0.2794155 , 0.41211849, 0.84147098, 0.98935825], [ 0.41211849, 0.84147098, 0.90929743, 0.98935825, 0.41211849], [ 0.41211849, -0.95892427, 0. , 0.90929743, 0.6569866 ]])12arr = np.random.random(size=(3,4))arr array([[0.07961309, 0.30545992, 0.33071931, 0.7738303 ], [0.03995921, 0.42949218, 0.31492687, 0.63649114], [0.34634715, 0.04309736, 0.87991517, 0.76324059]])1np.around(arr,decimals=2) array([[0.08, 0.31, 0.33, 0.77], [0.04, 0.43, 0.31, 0.64], [0.35, 0.04, 0.88, 0.76]])常用的统计函数 numpy.amin() 和 numpy.amax()，用于计算数组中的元素沿指定轴的最小、最大值。 numpy.ptp():计算数组中元素最大值与最小值的差（最大值 - 最小值）。 numpy.median() 函数用于计算数组 a 中元素的中位数（中值） 标准差std():标准差是一组数据平均值分散程度的一种度量。 公式：std = sqrt(mean((x - x.mean())**2)) 如果数组是 [1，2，3，4]，则其平均值为 2.5。 因此，差的平方是 [2.25,0.25,0.25,2.25]，并且其平均值的平方根除以 4，即 sqrt(5/4) ，结果为 1.1180339887498949。 方差var()：统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即 mean((x - x.mean())** 2)。换句话说，标准差是方差的平方根。 12arr = np.random.randint(0,20,size=(5,3))arr array([[12, 18, 17], [17, 16, 0], [ 5, 9, 0], [ 6, 0, 2], [ 3, 3, 18]])1np.amin(arr,axis=0) array([3, 0, 0])1np.ptp(arr,axis=0) array([14, 18, 18])1np.median(arr,axis=0) array([6., 9., 2.])1np.std(arr,axis=0) array([5.16139516, 7.02566723, 8.28492607])1np.var(arr,axis=0) array([26.64, 49.36, 68.64])矩阵相关 NumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象。一个 的矩阵是一个由行（row）列（column）元素排列成的矩形阵列。 matlib.empty() 函数返回一个新的矩阵，语法格式为：numpy.matlib.empty(shape, dtype)，填充为随机数据 参数介绍： shape: 定义新矩阵形状的整数或整数元组 Dtype: 可选，数据类型 12import numpy.matlib as matlibmatlib.empty(shape=(4,5)) matrix([[-0.2794155 , -0.2794155 , -0.95892427, -0.2794155 , 0. ], [ 0. , -0.2794155 , 0.41211849, 0.84147098, 0.98935825], [ 0.41211849, 0.84147098, 0.90929743, 0.98935825, 0.41211849], [ 0.41211849, -0.95892427, 0. , 0.90929743, 0.6569866 ]]) numpy.matlib.zeros()，numpy.matlib.ones()返回填充为0或者1的矩阵 12 numpy.matlib.eye() 函数返回一个矩阵，对角线元素为 1，其他位置为零。 numpy.matlib.eye(n, M,k, dtype) n: 返回矩阵的行数 M: 返回矩阵的列数，默认为 n k: 对角线的索引 dtype: 数据类型 1matlib.eye(5,5,1) matrix([[0., 1., 0., 0., 0.], [0., 0., 1., 0., 0.], [0., 0., 0., 1., 0.], [0., 0., 0., 0., 1.], [0., 0., 0., 0., 0.]]) numpy.matlib.identity() 函数返回给定大小的单位矩阵。单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1，除此以外全都为 0。 1matlib.identity(6) matrix([[1., 0., 0., 0., 0., 0.], [0., 1., 0., 0., 0., 0.], [0., 0., 1., 0., 0., 0.], [0., 0., 0., 1., 0., 0.], [0., 0., 0., 0., 1., 0.], [0., 0., 0., 0., 0., 1.]]) 转置矩阵 .T 12arr = matlib.identity(6)arr matrix([[1., 0., 0., 0., 0., 0.], [0., 1., 0., 0., 0., 0.], [0., 0., 1., 0., 0., 0.], [0., 0., 0., 1., 0., 0.], [0., 0., 0., 0., 1., 0.], [0., 0., 0., 0., 0., 1.]])12a = np.array([[1,2,3],[4,5,6]])a array([[1, 2, 3], [4, 5, 6]])1a.T array([[1, 4], [2, 5], [3, 6]]) 矩阵相乘 numpy.dot(a, b, out=None) a : ndarray 数组 b : ndarray 数组 第一个矩阵第一行的每个数字（2和1），各自乘以第二个矩阵第一列对应位置的数字（1和1），然后将乘积相加（ 2 x 1 + 1 x 1），得到结果矩阵左上角的那个值3。也就是说，结果矩阵第m行与第n列交叉位置的那个值，等于第一个矩阵第m行与第二个矩阵第n列，对应位置的每个值的乘积之和。 线性代数基于矩阵的推导： https://www.cnblogs.com/alantu2018/p/8528299.html 123arr_1 = np.array([[1,2,3],[4,5,6]]) #2行3列arr_2 = np.array([[1,2,3],[4,5,6]]) arr_2 = arr_2.T 1arr_1 array([[1, 2, 3], [4, 5, 6]])1arr_2 array([[1, 4], [2, 5], [3, 6]])1np.dot(arr_1,arr_2) array([[14, 32], [32, 77]])","link":"/2020/01/08/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-numpy%E6%A8%A1%E5%9D%97/"},{"title":"pandas基础","text":"为什么学习pandas numpy已经可以帮助我们进行数据的处理了，那么学习pandas的目的是什么呢？ numpy能够帮助我们处理的是数值型的数据，当然在数据分析中除了数值型的数据还有好多其他类型的数据（字符串，时间序列），那么pandas就可以帮我们很好的处理除了数值型的其他数据！ 什么是pandas？ 首先先来认识pandas中的两个常用的类 Series DataFrame 123import pandas as pdfrom pandas import Series,DataFrameimport numpy as np Series Series是一种类似与一维数组的对象，由下面两个部分组成： values：一组数据（ndarray类型） index：相关的数据索引标签 Series的创建 由列表或numpy数组创建 由字典创建 12s = Series(data=[1,2,3,4,5])s 0 1 1 2 2 3 3 4 4 5 dtype: int64 Series的索引 隐式索引：默认 显式索引：增强数据的可读性 index的参数指定 12s1 = Series(data=[1,2,3],index=['a','b','c'])s1 a 1 b 2 c 3 dtype: int64123456dic = { '数学':100, '理综':188}s3 = Series(data=dic)s3 数学 100 理综 188 dtype: int6412s4 = Series(data=np.random.randint(0,100,size=(3,)))s4 0 9 1 91 2 24 dtype: int32 Series的索引和切片 1s1 a 1 b 2 c 3 dtype: int64123s1['a']s1[0]s1.a 112s1[0:2]s1['a':'c'] a 1 b 2 c 3 dtype: int64 Series的常用属性 shape size index values 1234s1.shape # 形状s1.size # 尺寸s1.index # 索引s1.values array([1, 2, 3], dtype=int64) Series的常用方法 head(),tail() unique() isnull(),notnull() add() sub() mul() div() 12s1.head(2)# 只显示前两行数据s1.tail(2)# 只显示后两行数据 b 2 c 3 dtype: int64 Series的算术运算 123s1 = Series(data=[1,2,3,4],index=['a','b','c','d'])s2 = Series(data=[1,2,3,4],index=['a','b','e','d'])s1 a 1 b 2 c 3 d 4 dtype: int641s2 a 1 b 2 e 3 d 4 dtype: int64 Series的运算法则： 索引一致的元素值进行算数运算，否则补空 12s = s1+s2s a 2.0 b 4.0 c NaN d 8.0 e NaN dtype: float64 基于Series的空值（缺失值）过滤 isnull,notnull:判断某些元素是否为空值 1s.isnull() a False b False c True d False e True dtype: bool123#使用隐事和显示索引s[[0,1,2]]s[['a','c']] a 2.0 c NaN dtype: float641s a 2.0 b 4.0 c NaN d 8.0 e NaN dtype: float6412#使用布尔值充当索引s[[True,True,False,True,False]] a 2.0 b 4.0 d 8.0 dtype: float641s.notnull() a True b True c False d True e False dtype: bool1s[s.notnull()] a 2.0 b 4.0 d 8.0 dtype: float64DataFrame DataFrame是一个【表格型】的数据结构。DataFrame由按一定顺序排列的多列数据组成。设计初衷是将Series的使用场景从一维拓展到多维。DataFrame既有行索引，也有列索引。 行索引：index 列索引：columns 值：values DataFrame的创建 ndarray创建 字典创建 1DataFrame(data=np.random.randint(0,100,size=(4,6))) 0 1 2 3 4 5 0 93 24 73 95 46 36 1 17 98 7 13 79 34 2 82 51 52 21 4 50 3 77 23 91 31 6 12 123456dic = { 'name':['张三','李四','王老五'], 'salary':[10000,20000,15555]}df = DataFrame(data=dic,index=['a','b','c'])df name salary a 张三 10000 b 李四 20000 c 王老五 15555 DataFrame的属性 values、columns、index、shape 1234df.valuesdf.columnsdf.indexdf.shape (3, 2)============================================ 练习4： 根据以下考试成绩表，创建一个DataFrame，命名为df： 12345 张三 李四 语文 150 0数学 150 0英语 150 0理综 300 0 ============================================ 123lst = [[150,0],[150,0],[150,0],[150,0]]da = DataFrame(data=lst,index=['语文','数学','英语','理综'],columns=['张三','李四'])da 张三 李四 语文 150 0 数学 150 0 英语 150 0 理综 150 0 123456dic = { '张三':[150,150,150,150], '李四':[0,0,0,0]}da = DataFrame(data=dic,index=['语文','数学','英语','理综'])da 张三 李四 语文 150 0 数学 150 0 英语 150 0 理综 150 0 DataFrame索引操作 对行进行索引 队列进行索引 对元素进行索引 1df name salary a 张三 10000 b 李四 20000 c 王老五 15555 12#取出第一列df['name'] a 张三 b 李四 c 王老五 Name: name, dtype: object12#取出多列df[['name','salary']] name salary a 张三 10000 b 李四 20000 c 王老五 15555 12#取出一行df.loc['a'] name 张三 salary 10000 Name: a, dtype: object12#取多行df.loc[['a','c']] name salary a 张三 10000 c 王老五 15555 1df.iloc[[1,2]] name salary b 李四 20000 c 王老五 15555 loc[‘显示索引’] iloc[隐事索引] 1df name salary a 张三 10000 b 李四 20000 c 王老五 15555 123#取单个的元素（李四的薪资取出）df.iloc[1,1]df.loc['b','salary'] 2000012#取多个个的元素df.loc[['a','c'],'salary'] a 10000 c 15555 Name: salary, dtype: int64 DataFrame的切片操作 对行进行切片 对列进行切片 12#切出前两行df[0:2] name salary a 张三 10000 b 李四 20000 12#切出前两列df.iloc[:,0:2] name salary a 张三 10000 b 李四 20000 c 王老五 15555 索引和切片的汇总 索引： df[col]:取单列 df[[col1,col2]]:取多列 df.loc[row]:取单行 df.loc[[row1,row2]]:取多行 df.loc[row,col]:取元素 切片 切行：df[row1:row3] 切列：df.loc[:,col1:col3] DataFrame的运算:和Series的运算法则一样 时间数据类型的转换 pd.to_datetime(col) 将某一列设置为行索引 df.set_index() 股票： 使用tushare包获取某股票的历史行情数据。 tushre财经数据接口包：提供了各种财经历史交易数据 下载tushare：pip install tushare 输出该股票所有收盘比开盘上涨3%以上的日期。 输出该股票所有开盘比前日收盘跌幅超过2%的日期。 假如我从2010年1月1日开始，每月第一个交易日买入1手股票，每年最后一个交易日卖出所有股票，到今天为止，我的收益如何？ 12import tushare as tsdf = ts.get_k_data('600519',start='2000-01-01') # 日期尽可能写早，会读出所有数据 12#写入到文件df.to_csv('./maotai.csv') 123#将本地的数据读取到dfdf = pd.read_csv('./maotai.csv')df.head(5) Unnamed: 0 date open close high low volume code 0 0 2001-08-27 5.392 5.554 5.902 5.132 406318.00 600519 1 1 2001-08-28 5.467 5.759 5.781 5.407 129647.79 600519 2 2 2001-08-29 5.777 5.684 5.781 5.640 53252.75 600519 3 3 2001-08-30 5.668 5.796 5.860 5.624 48013.06 600519 4 4 2001-08-31 5.804 5.782 5.877 5.749 23231.48 600519 12#将无用的列删除.drop系列的函数中axis=0行，1列df.drop(labels='Unnamed: 0',axis=1,inplace=True) #inplace=True把数据从原始数据中删除 df.info(): 返回df中一些原始信息 数据的行数 每一列元素的数据类型 检测列中是否有缺失数据 1df.info() &lt;class &apos;pandas.core.frame.DataFrame&apos;&gt; RangeIndex: 4388 entries, 0 to 4387 Data columns (total 7 columns): date 4388 non-null object open 4388 non-null float64 close 4388 non-null float64 high 4388 non-null float64 low 4388 non-null float64 volume 4388 non-null float64 code 4388 non-null int64 dtypes: float64(5), int64(1), object(1) memory usage: 240.1+ KB12##将date列中的数据类型转换成时间序列类型df['date'] = pd.to_datetime(df['date']) 1df.info() &lt;class &apos;pandas.core.frame.DataFrame&apos;&gt; RangeIndex: 4388 entries, 0 to 4387 Data columns (total 7 columns): date 4388 non-null datetime64[ns] open 4388 non-null float64 close 4388 non-null float64 high 4388 non-null float64 low 4388 non-null float64 volume 4388 non-null float64 code 4388 non-null int64 dtypes: datetime64[ns](1), float64(5), int64(1) memory usage: 240.1 KB12#将date列作为源数据的行索引df.set_index('date',inplace=True) 1df.head() open close high low volume code date 2001-08-27 5.392 5.554 5.902 5.132 406318.00 600519 2001-08-28 5.467 5.759 5.781 5.407 129647.79 600519 2001-08-29 5.777 5.684 5.781 5.640 53252.75 600519 2001-08-30 5.668 5.796 5.860 5.624 48013.06 600519 2001-08-31 5.804 5.782 5.877 5.749 23231.48 600519 123#输出该股票所有收盘比开盘上涨3%以上的日期。#（收盘-开盘）/开盘 &gt; 0.03(df['close'] - df['open'])/df['open'] &gt; 0.03 date 2001-08-27 True 2001-08-28 True 2001-08-29 False 2001-08-30 False 2001-08-31 False ... 2020-01-09 False 2020-01-10 False 2020-01-13 False 2020-01-14 False 2020-01-15 False Length: 4388, dtype: bool123#测试#一组布尔值是可以作为df的行索引，不可作为列索引df.loc[[True,False,True]] 12#将布尔值作为了源数据df的行索引，可以取出True对应的行数据df.loc[(df['close'] - df['open'])/df['open'] &gt; 0.03] open close high low volume code date 2001-08-27 5.392 5.554 5.902 5.132 406318.00 600519 2001-08-28 5.467 5.759 5.781 5.407 129647.79 600519 2001-09-10 5.531 5.734 5.757 5.470 18878.89 600519 2001-12-21 5.421 5.604 5.620 5.421 8135.04 600519 2002-01-18 5.437 5.726 5.762 5.421 32262.08 600519 ... ... ... ... ... ... ... 2019-06-11 876.000 910.890 915.610 875.000 80106.00 600519 2019-06-20 932.500 975.000 975.500 932.200 67271.00 600519 2019-09-12 1066.000 1099.000 1109.980 1066.000 41211.00 600519 2019-09-18 1108.500 1148.900 1150.000 1108.180 69314.00 600519 1df.loc[(df['close'] - df['open'])/df['open'] &gt; 0.03].index DatetimeIndex([&apos;2001-08-27&apos;, &apos;2001-08-28&apos;, &apos;2001-09-10&apos;, &apos;2001-12-21&apos;, &apos;2002-01-18&apos;, &apos;2002-01-31&apos;, &apos;2003-01-14&apos;, &apos;2003-10-29&apos;, &apos;2004-01-05&apos;, &apos;2004-01-14&apos;, ... &apos;2019-03-01&apos;, &apos;2019-03-18&apos;, &apos;2019-04-10&apos;, &apos;2019-04-16&apos;, &apos;2019-05-10&apos;, &apos;2019-05-15&apos;, &apos;2019-06-11&apos;, &apos;2019-06-20&apos;, &apos;2019-09-12&apos;, &apos;2019-09-18&apos;], dtype=&apos;datetime64[ns]&apos;, name=&apos;date&apos;, length=303, freq=None) shift(1):将Series的数据整体向下移动一位 123#输出该股票所有开盘比前日收盘跌幅超过2%的日期#（开盘-前日收盘）/前日收盘 &lt; -0.02(df['open'] - df['close'].shift(1))/df['close'].shift(1) &lt; -0.02 date 2001-08-27 False 2001-08-28 False 2001-08-29 False 2001-08-30 False 2001-08-31 False ... 2020-01-06 False 2020-01-07 False 2020-01-08 False 2020-01-09 False 2020-01-10 False Length: 4385, dtype: bool12#将布尔值作为源数据的行索引df.loc[(df['open'] - df['close'].shift(1))/df['close'].shift(1) &lt; -0.02].index DatetimeIndex([&apos;2001-09-12&apos;, &apos;2002-06-26&apos;, &apos;2002-12-13&apos;, &apos;2004-07-01&apos;, &apos;2004-10-29&apos;, &apos;2006-08-21&apos;, &apos;2006-08-23&apos;, &apos;2007-01-25&apos;, &apos;2007-02-01&apos;, &apos;2007-02-06&apos;, &apos;2007-03-19&apos;, &apos;2007-05-21&apos;, &apos;2007-05-30&apos;, &apos;2007-06-05&apos;, &apos;2007-07-27&apos;, &apos;2007-09-05&apos;, &apos;2007-09-10&apos;, &apos;2008-03-13&apos;, &apos;2008-03-17&apos;, &apos;2008-03-25&apos;, &apos;2008-03-27&apos;, &apos;2008-04-22&apos;, &apos;2008-04-23&apos;, &apos;2008-04-29&apos;, &apos;2008-05-13&apos;, &apos;2008-06-10&apos;, &apos;2008-06-13&apos;, &apos;2008-06-24&apos;, &apos;2008-06-27&apos;, &apos;2008-08-11&apos;, &apos;2008-08-19&apos;, &apos;2008-09-23&apos;, &apos;2008-10-10&apos;, &apos;2008-10-15&apos;, &apos;2008-10-16&apos;, &apos;2008-10-20&apos;, &apos;2008-10-23&apos;, &apos;2008-10-27&apos;, &apos;2008-11-06&apos;, &apos;2008-11-12&apos;, &apos;2008-11-20&apos;, &apos;2008-11-21&apos;, &apos;2008-12-02&apos;, &apos;2009-02-27&apos;, &apos;2009-03-25&apos;, &apos;2009-08-13&apos;, &apos;2010-04-26&apos;, &apos;2010-04-30&apos;, &apos;2011-08-05&apos;, &apos;2012-03-27&apos;, &apos;2012-08-10&apos;, &apos;2012-11-22&apos;, &apos;2012-12-04&apos;, &apos;2012-12-24&apos;, &apos;2013-01-16&apos;, &apos;2013-01-25&apos;, &apos;2013-09-02&apos;, &apos;2014-04-25&apos;, &apos;2015-01-19&apos;, &apos;2015-05-25&apos;, &apos;2015-07-03&apos;, &apos;2015-07-08&apos;, &apos;2015-07-13&apos;, &apos;2015-08-24&apos;, &apos;2015-09-02&apos;, &apos;2015-09-15&apos;, &apos;2017-11-17&apos;, &apos;2018-02-06&apos;, &apos;2018-02-09&apos;, &apos;2018-03-23&apos;, &apos;2018-03-28&apos;, &apos;2018-07-11&apos;, &apos;2018-10-11&apos;, &apos;2018-10-24&apos;, &apos;2018-10-25&apos;, &apos;2018-10-29&apos;, &apos;2018-10-30&apos;, &apos;2019-05-06&apos;, &apos;2019-05-08&apos;, &apos;2019-10-16&apos;, &apos;2020-01-02&apos;], dtype=&apos;datetime64[ns]&apos;, name=&apos;date&apos;, freq=None) 假如我从2010年1月1日开始，每月第一个交易日买入1手股票，每年最后一个交易日卖出所有股票，到今天为止，我的收益如何？ 分析：设定买卖股票是基于股票的开盘价进行买卖的 买入： 一个完整的年需要买入12次股票共计1200只 将每月第一个交易日对应的行数据取出，从行数据中提取出购买的单价（开盘价） 卖出： 一个完整的年需要卖出1次股票共计1200只 将每年最后一个交易日的行数据取出，从行数据中提取出售卖的单价（开盘价） 特殊情况： 在2020年只可以买入100只股票但是无法卖出。但是剩余股票的价值也需要计算到总收益中 1data = df['2010':'2020'] #data表示的是2010-2020年之间的历史交易数据 123#数据的重新取样resampledata_monthly = data.resample('M').first()data_monthly.head()#存储就是每月第一个叫日期对应的行数据 open close high low volume code date 2010-01-31 109.760 108.446 109.760 108.044 44304.88 600519 2010-02-28 107.769 107.776 108.216 106.576 29655.94 600519 2010-03-31 106.219 106.085 106.857 105.925 21734.74 600519 2010-04-30 101.324 102.141 102.422 101.311 23980.83 600519 2010-05-31 81.676 82.091 82.678 80.974 23975.16 600519 123#计算2010-2020期间买入股票的花费cost_monry = data_monthly['open'].sum()*100cost_monry 3911706.11234#买入股票收入多少钱data_yearly = data.resample('A').last()[:-1]recv_money = data_yearly['open'].sum() * 1200recv_money 4368184.812#剩余1手股票的实际价值(最后一天的开盘价作为剩余股票价值的单价)last_monry = 100 * data['open'][-1] 12#总收益last_monry+recv_money-cost_monry 567378.6999999997","link":"/2020/01/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-pandas%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"数据分析","slug":"数据分析","link":"/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"categories":[{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Django","slug":"Python/Django","link":"/categories/Python/Django/"},{"name":"数据分析","slug":"数据分析","link":"/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}]}