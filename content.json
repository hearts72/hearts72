{"pages":[],"posts":[{"title":"数据分析","text":"什么是数据分析 是把隐藏在一些看似杂乱无章的数据背后的信息提炼出来，总结出所研究对象的内在规律 数据分析是用适当的方法对收集来的大量数据进行分析，帮助人们做出判断，以便采取适当的行动 商品采购量的多少 总部向各个地区代理的发货量 …… 数据分析实现流程 提出问题 准备数据 分析数据 获得结论 成果可视化 数据分析三剑客 numpy pandas matplotlib numpy模块：一维或者是多维的数组（低版本的列表） NumPy(Numerical Python) 是 Python 语言中做科学计算的基础库。重在于数值计算，也是大部分Python科学计算库的基础，多用于在大型、多维数组上执行的数值运算。 numpy的创建 使用np.array()创建 使用plt创建 使用np的routines函数创建 使用array()创建一个一维数组 123import numpy as nparr = np.array([1,2,3,4,5,6])arr array([1, 2, 3, 4, 5, 6]) 使用array()创建一个多维数组 1np.array([[1,2,3,4],[5,6,7,8],[9,9,9,9]]) array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 9, 9, 9]]) 数组和列表的区别是什么？ 数据中存储的数组元素的数据类型必须是统一 数据类型是有优先级： str&gt;float&gt;int 12arr = np.array([1,2.2,3,4,5,6])arr array([1. , 2.2, 3. , 4. , 5. , 6. ]) 将外部的一张图片读取加载到numpy数组中，然后尝试改变数组元素的数值查看对原始图片的影响 123import matplotlib.pyplot as pltimg_arr = plt.imread('./assets/1.jpg')plt.imshow(img_arr) &lt;matplotlib.image.AxesImage at 0x16e9faebb70&gt; 1plt.imshow(img_arr-100) &lt;matplotlib.image.AxesImage at 0x16eb3240dd8&gt; zeros() ones() linespace() arange() random系列 1np.zeros((3,4)) array([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]])1np.linspace(0,100,num=20) array([ 0. , 5.26315789, 10.52631579, 15.78947368, 21.05263158, 26.31578947, 31.57894737, 36.84210526, 42.10526316, 47.36842105, 52.63157895, 57.89473684, 63.15789474, 68.42105263, 73.68421053, 78.94736842, 84.21052632, 89.47368421, 94.73684211, 100. ])1np.arange(0,100,step=3) array([ 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99])1np.random.randint(0,100,size=(5,6)) array([[71, 76, 47, 11, 7, 6], [47, 89, 70, 44, 41, 96], [58, 42, 36, 53, 49, 55], [13, 32, 64, 58, 15, 7], [78, 56, 40, 71, 45, 63]])1np.random.random((3,4)) array([[0.24913375, 0.91988476, 0.36386714, 0.58404557], [0.15544885, 0.73892461, 0.82189615, 0.80368295], [0.07230386, 0.45535116, 0.75370029, 0.03377829]]) 随机性： 随机因子：x(时间) 123#固定随机性np.random.seed(10)np.random.randint(0,100,size=(5,6)) array([[ 9, 15, 64, 28, 89, 93], [29, 8, 73, 0, 40, 36], [16, 11, 54, 88, 62, 33], [72, 78, 49, 51, 54, 77], [69, 13, 25, 13, 92, 86]])numpy的常用属性 shape ndim size dtype 12345img_arr.shapeimg_arr.ndimimg_arr.sizeimg_arr.dtypetype(img_arr) numpy.ndarray1arr = np.array([1,2,3],dtype='uint8') numpy的数据类型 array(dtype=?):可以设定数据类型 arr.dtype = ‘?’:可以修改数据类型 1arr = np.array([1,2,3]) 1arr.dtype = 'int32' numpy的索引和切片操作（重点） 索引操作和列表同理 12arr = np.random.randint(0,100,size=(6,8))arr array([[30, 30, 89, 12, 65, 31, 57, 36], [27, 18, 93, 77, 22, 23, 94, 11], [28, 74, 88, 9, 15, 18, 80, 71], [88, 11, 17, 46, 7, 75, 28, 33], [84, 96, 88, 44, 5, 4, 71, 88], [88, 50, 54, 34, 15, 77, 88, 15]])1arr[1] array([27, 18, 93, 77, 22, 23, 94, 11]) 切片操作 切出前两列数据 切出前两行数据 切出前两行的前两列的数据 数组数据翻转 练习：将一张图片上下左右进行翻转操作 练习：将图片进行指定区域的裁剪 1arr.shape (6, 8)12#切出前两行arr[0:2] array([[30, 30, 89, 12, 65, 31, 57, 36], [27, 18, 93, 77, 22, 23, 94, 11]])12#切出前两列arr[hang,lie]arr[:,0:2] array([[30, 30], [27, 18], [28, 74], [88, 11], [84, 96], [88, 50]])12#切出前两行的前两列的数据arr[0:2,0:2] array([[30, 30], [27, 18]])12#数组数据翻转plt.imshow(img_arr) &lt;matplotlib.image.AxesImage at 0x16eb30833c8&gt; 1img_arr.shape #前两个维度表示的是像素，最后一个维度表示颜色 (426, 640, 3)12#将图片进行上下翻转plt.imshow(img_arr[::-1,:,:]) &lt;matplotlib.image.AxesImage at 0x16eb30de828&gt; 1plt.imshow(img_arr[:,::-1,:]) &lt;matplotlib.image.AxesImage at 0x16eb313b8d0&gt; 1plt.imshow(img_arr[::-1,::-1,::-1]) &lt;matplotlib.image.AxesImage at 0x16eb3198a58&gt; 12#裁剪plt.imshow(img_arr) &lt;matplotlib.image.AxesImage at 0x16eb31f8898&gt; 1plt.imshow(img_arr[50:450,300:750,:]) &lt;matplotlib.image.AxesImage at 0x16eb5164470&gt; 切片汇总： 切行：arr[index1:index3] 切列：arr[行切片,列切片] 翻转：arr[::-1] 变形reshape 变形前和变形后对应的数组元素个数是一致 12arr = np.array([1,2,3,4,5,6])arr array([1, 2, 3, 4, 5, 6])12#将一维数组变形成二维arr.reshape((2,3)) array([[1, 2, 3], [4, 5, 6]])1arr.reshape((-1,2)) array([[1, 2], [3, 4], [5, 6]])级联操作：concatenate 是对numpy数组进行横向或者纵向的拼接 axis轴向的理解 0:列 1：行 12arr1 = np.array([[1,2,3],[4,5,6]])arr1 array([[1, 2, 3], [4, 5, 6]])1np.concatenate((arr1,arr1),axis=1) array([[1, 2, 3, 1, 2, 3], [4, 5, 6, 4, 5, 6]])12arr2 = np.array([[1,2,3,3],[4,5,6,6]])arr2 array([[1, 2, 3, 3], [4, 5, 6, 6]]) 匹配级联 级联的多个数组的形状是一样 不匹配级联 级联的多个数组的形状是不一样（维度必须一样） 多个数组的行数一样进行行级联 多个数组的列数一样进行列级联 12#讲arr1和arr2进行级联np.concatenate((arr1,arr2),axis=1) array([[1, 2, 3, 1, 2, 3, 3], [4, 5, 6, 4, 5, 6, 6]])常用的聚合操作 sum,max,min,mean 12arr = np.random.randint(0,10,size=(4,5))arr array([[6, 6, 5, 6, 0], [0, 6, 9, 1, 8], [9, 1, 2, 8, 9], [9, 5, 0, 2, 7]])1arr.sum(axis=1) array([23, 24, 29, 23])常用的数学函数 NumPy 提供了标准的三角函数：sin()、cos()、tan() numpy.around(a,decimals) 函数返回指定数字的四舍五入值。 参数说明： a: 数组 decimals: 舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置 1np.sin(arr) array([[-0.2794155 , -0.2794155 , -0.95892427, -0.2794155 , 0. ], [ 0. , -0.2794155 , 0.41211849, 0.84147098, 0.98935825], [ 0.41211849, 0.84147098, 0.90929743, 0.98935825, 0.41211849], [ 0.41211849, -0.95892427, 0. , 0.90929743, 0.6569866 ]])12arr = np.random.random(size=(3,4))arr array([[0.07961309, 0.30545992, 0.33071931, 0.7738303 ], [0.03995921, 0.42949218, 0.31492687, 0.63649114], [0.34634715, 0.04309736, 0.87991517, 0.76324059]])1np.around(arr,decimals=2) array([[0.08, 0.31, 0.33, 0.77], [0.04, 0.43, 0.31, 0.64], [0.35, 0.04, 0.88, 0.76]])常用的统计函数 numpy.amin() 和 numpy.amax()，用于计算数组中的元素沿指定轴的最小、最大值。 numpy.ptp():计算数组中元素最大值与最小值的差（最大值 - 最小值）。 numpy.median() 函数用于计算数组 a 中元素的中位数（中值） 标准差std():标准差是一组数据平均值分散程度的一种度量。 公式：std = sqrt(mean((x - x.mean())**2)) 如果数组是 [1，2，3，4]，则其平均值为 2.5。 因此，差的平方是 [2.25,0.25,0.25,2.25]，并且其平均值的平方根除以 4，即 sqrt(5/4) ，结果为 1.1180339887498949。 方差var()：统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即 mean((x - x.mean())** 2)。换句话说，标准差是方差的平方根。 12arr = np.random.randint(0,20,size=(5,3))arr array([[12, 18, 17], [17, 16, 0], [ 5, 9, 0], [ 6, 0, 2], [ 3, 3, 18]])1np.amin(arr,axis=0) array([3, 0, 0])1np.ptp(arr,axis=0) array([14, 18, 18])1np.median(arr,axis=0) array([6., 9., 2.])1np.std(arr,axis=0) array([5.16139516, 7.02566723, 8.28492607])1np.var(arr,axis=0) array([26.64, 49.36, 68.64])矩阵相关 NumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象。一个 的矩阵是一个由行（row）列（column）元素排列成的矩形阵列。 matlib.empty() 函数返回一个新的矩阵，语法格式为：numpy.matlib.empty(shape, dtype)，填充为随机数据 参数介绍： shape: 定义新矩阵形状的整数或整数元组 Dtype: 可选，数据类型 12import numpy.matlib as matlibmatlib.empty(shape=(4,5)) matrix([[-0.2794155 , -0.2794155 , -0.95892427, -0.2794155 , 0. ], [ 0. , -0.2794155 , 0.41211849, 0.84147098, 0.98935825], [ 0.41211849, 0.84147098, 0.90929743, 0.98935825, 0.41211849], [ 0.41211849, -0.95892427, 0. , 0.90929743, 0.6569866 ]]) numpy.matlib.zeros()，numpy.matlib.ones()返回填充为0或者1的矩阵 12 numpy.matlib.eye() 函数返回一个矩阵，对角线元素为 1，其他位置为零。 numpy.matlib.eye(n, M,k, dtype) n: 返回矩阵的行数 M: 返回矩阵的列数，默认为 n k: 对角线的索引 dtype: 数据类型 1matlib.eye(5,5,1) matrix([[0., 1., 0., 0., 0.], [0., 0., 1., 0., 0.], [0., 0., 0., 1., 0.], [0., 0., 0., 0., 1.], [0., 0., 0., 0., 0.]]) numpy.matlib.identity() 函数返回给定大小的单位矩阵。单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1，除此以外全都为 0。 1matlib.identity(6) matrix([[1., 0., 0., 0., 0., 0.], [0., 1., 0., 0., 0., 0.], [0., 0., 1., 0., 0., 0.], [0., 0., 0., 1., 0., 0.], [0., 0., 0., 0., 1., 0.], [0., 0., 0., 0., 0., 1.]]) 转置矩阵 .T 12arr = matlib.identity(6)arr matrix([[1., 0., 0., 0., 0., 0.], [0., 1., 0., 0., 0., 0.], [0., 0., 1., 0., 0., 0.], [0., 0., 0., 1., 0., 0.], [0., 0., 0., 0., 1., 0.], [0., 0., 0., 0., 0., 1.]])12a = np.array([[1,2,3],[4,5,6]])a array([[1, 2, 3], [4, 5, 6]])1a.T array([[1, 4], [2, 5], [3, 6]]) 矩阵相乘 numpy.dot(a, b, out=None) a : ndarray 数组 b : ndarray 数组 第一个矩阵第一行的每个数字（2和1），各自乘以第二个矩阵第一列对应位置的数字（1和1），然后将乘积相加（ 2 x 1 + 1 x 1），得到结果矩阵左上角的那个值3。也就是说，结果矩阵第m行与第n列交叉位置的那个值，等于第一个矩阵第m行与第二个矩阵第n列，对应位置的每个值的乘积之和。 线性代数基于矩阵的推导： https://www.cnblogs.com/alantu2018/p/8528299.html 123arr_1 = np.array([[1,2,3],[4,5,6]]) #2行3列arr_2 = np.array([[1,2,3],[4,5,6]]) arr_2 = arr_2.T 1arr_1 array([[1, 2, 3], [4, 5, 6]])1arr_2 array([[1, 4], [2, 5], [3, 6]])1np.dot(arr_1,arr_2) array([[14, 32], [32, 77]])","link":"/2020/01/08/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-numpy%E6%A8%A1%E5%9D%97/"},{"title":"pandas基础","text":"为什么学习pandas numpy已经可以帮助我们进行数据的处理了，那么学习pandas的目的是什么呢？ numpy能够帮助我们处理的是数值型的数据，当然在数据分析中除了数值型的数据还有好多其他类型的数据（字符串，时间序列），那么pandas就可以帮我们很好的处理除了数值型的其他数据！ 什么是pandas？ 首先先来认识pandas中的两个常用的类 Series DataFrame 123import pandas as pdfrom pandas import Series,DataFrameimport numpy as np Series Series是一种类似与一维数组的对象，由下面两个部分组成： values：一组数据（ndarray类型） index：相关的数据索引标签 Series的创建 由列表或numpy数组创建 由字典创建 12s = Series(data=[1,2,3,4,5])s 0 1 1 2 2 3 3 4 4 5 dtype: int64 Series的索引 隐式索引：默认 显式索引：增强数据的可读性 index的参数指定 12s1 = Series(data=[1,2,3],index=['a','b','c'])s1 a 1 b 2 c 3 dtype: int64123456dic = { '数学':100, '理综':188}s3 = Series(data=dic)s3 数学 100 理综 188 dtype: int6412s4 = Series(data=np.random.randint(0,100,size=(3,)))s4 0 9 1 91 2 24 dtype: int32 Series的索引和切片 1s1 a 1 b 2 c 3 dtype: int64123s1['a']s1[0]s1.a 112s1[0:2]s1['a':'c'] a 1 b 2 c 3 dtype: int64 Series的常用属性 shape size index values 1234s1.shape # 形状s1.size # 尺寸s1.index # 索引s1.values array([1, 2, 3], dtype=int64) Series的常用方法 head(),tail() unique() isnull(),notnull() add() sub() mul() div() 12s1.head(2)# 只显示前两行数据s1.tail(2)# 只显示后两行数据 b 2 c 3 dtype: int64 Series的算术运算 123s1 = Series(data=[1,2,3,4],index=['a','b','c','d'])s2 = Series(data=[1,2,3,4],index=['a','b','e','d'])s1 a 1 b 2 c 3 d 4 dtype: int641s2 a 1 b 2 e 3 d 4 dtype: int64 Series的运算法则： 索引一致的元素值进行算数运算，否则补空 12s = s1+s2s a 2.0 b 4.0 c NaN d 8.0 e NaN dtype: float64 基于Series的空值（缺失值）过滤 isnull,notnull:判断某些元素是否为空值 1s.isnull() a False b False c True d False e True dtype: bool123#使用隐事和显示索引s[[0,1,2]]s[['a','c']] a 2.0 c NaN dtype: float641s a 2.0 b 4.0 c NaN d 8.0 e NaN dtype: float6412#使用布尔值充当索引s[[True,True,False,True,False]] a 2.0 b 4.0 d 8.0 dtype: float641s.notnull() a True b True c False d True e False dtype: bool1s[s.notnull()] a 2.0 b 4.0 d 8.0 dtype: float64DataFrame DataFrame是一个【表格型】的数据结构。DataFrame由按一定顺序排列的多列数据组成。设计初衷是将Series的使用场景从一维拓展到多维。DataFrame既有行索引，也有列索引。 行索引：index 列索引：columns 值：values DataFrame的创建 ndarray创建 字典创建 1DataFrame(data=np.random.randint(0,100,size=(4,6))) 0 1 2 3 4 5 0 93 24 73 95 46 36 1 17 98 7 13 79 34 2 82 51 52 21 4 50 3 77 23 91 31 6 12 123456dic = { 'name':['张三','李四','王老五'], 'salary':[10000,20000,15555]}df = DataFrame(data=dic,index=['a','b','c'])df name salary a 张三 10000 b 李四 20000 c 王老五 15555 DataFrame的属性 values、columns、index、shape 1234df.valuesdf.columnsdf.indexdf.shape (3, 2)============================================ 练习4： 根据以下考试成绩表，创建一个DataFrame，命名为df： 12345 张三 李四 语文 150 0数学 150 0英语 150 0理综 300 0 ============================================ 123lst = [[150,0],[150,0],[150,0],[150,0]]da = DataFrame(data=lst,index=['语文','数学','英语','理综'],columns=['张三','李四'])da 张三 李四 语文 150 0 数学 150 0 英语 150 0 理综 150 0 123456dic = { '张三':[150,150,150,150], '李四':[0,0,0,0]}da = DataFrame(data=dic,index=['语文','数学','英语','理综'])da 张三 李四 语文 150 0 数学 150 0 英语 150 0 理综 150 0 DataFrame索引操作 对行进行索引 队列进行索引 对元素进行索引 1df name salary a 张三 10000 b 李四 20000 c 王老五 15555 12#取出第一列df['name'] a 张三 b 李四 c 王老五 Name: name, dtype: object12#取出多列df[['name','salary']] name salary a 张三 10000 b 李四 20000 c 王老五 15555 12#取出一行df.loc['a'] name 张三 salary 10000 Name: a, dtype: object12#取多行df.loc[['a','c']] name salary a 张三 10000 c 王老五 15555 1df.iloc[[1,2]] name salary b 李四 20000 c 王老五 15555 loc[‘显示索引’] iloc[隐事索引] 1df name salary a 张三 10000 b 李四 20000 c 王老五 15555 123#取单个的元素（李四的薪资取出）df.iloc[1,1]df.loc['b','salary'] 2000012#取多个个的元素df.loc[['a','c'],'salary'] a 10000 c 15555 Name: salary, dtype: int64 DataFrame的切片操作 对行进行切片 对列进行切片 12#切出前两行df[0:2] name salary a 张三 10000 b 李四 20000 12#切出前两列df.iloc[:,0:2] name salary a 张三 10000 b 李四 20000 c 王老五 15555 索引和切片的汇总 索引： df[col]:取单列 df[[col1,col2]]:取多列 df.loc[row]:取单行 df.loc[[row1,row2]]:取多行 df.loc[row,col]:取元素 切片 切行：df[row1:row3] 切列：df.loc[:,col1:col3] DataFrame的运算:和Series的运算法则一样 时间数据类型的转换 pd.to_datetime(col) 将某一列设置为行索引 df.set_index() 股票： 使用tushare包获取某股票的历史行情数据。 tushre财经数据接口包：提供了各种财经历史交易数据 下载tushare：pip install tushare 输出该股票所有收盘比开盘上涨3%以上的日期。 输出该股票所有开盘比前日收盘跌幅超过2%的日期。 假如我从2010年1月1日开始，每月第一个交易日买入1手股票，每年最后一个交易日卖出所有股票，到今天为止，我的收益如何？ 12import tushare as tsdf = ts.get_k_data('600519',start='2000-01-01') # 日期尽可能写早，会读出所有数据 12#写入到文件df.to_csv('./maotai.csv') 123#将本地的数据读取到dfdf = pd.read_csv('./maotai.csv')df.head(5) Unnamed: 0 date open close high low volume code 0 0 2001-08-27 5.392 5.554 5.902 5.132 406318.00 600519 1 1 2001-08-28 5.467 5.759 5.781 5.407 129647.79 600519 2 2 2001-08-29 5.777 5.684 5.781 5.640 53252.75 600519 3 3 2001-08-30 5.668 5.796 5.860 5.624 48013.06 600519 4 4 2001-08-31 5.804 5.782 5.877 5.749 23231.48 600519 12#将无用的列删除.drop系列的函数中axis=0行，1列df.drop(labels='Unnamed: 0',axis=1,inplace=True) #inplace=True把数据从原始数据中删除 df.info(): 返回df中一些原始信息 数据的行数 每一列元素的数据类型 检测列中是否有缺失数据 1df.info() &lt;class &apos;pandas.core.frame.DataFrame&apos;&gt; RangeIndex: 4388 entries, 0 to 4387 Data columns (total 7 columns): date 4388 non-null object open 4388 non-null float64 close 4388 non-null float64 high 4388 non-null float64 low 4388 non-null float64 volume 4388 non-null float64 code 4388 non-null int64 dtypes: float64(5), int64(1), object(1) memory usage: 240.1+ KB12##将date列中的数据类型转换成时间序列类型df['date'] = pd.to_datetime(df['date']) 1df.info() &lt;class &apos;pandas.core.frame.DataFrame&apos;&gt; RangeIndex: 4388 entries, 0 to 4387 Data columns (total 7 columns): date 4388 non-null datetime64[ns] open 4388 non-null float64 close 4388 non-null float64 high 4388 non-null float64 low 4388 non-null float64 volume 4388 non-null float64 code 4388 non-null int64 dtypes: datetime64[ns](1), float64(5), int64(1) memory usage: 240.1 KB12#将date列作为源数据的行索引df.set_index('date',inplace=True) 1df.head() open close high low volume code date 2001-08-27 5.392 5.554 5.902 5.132 406318.00 600519 2001-08-28 5.467 5.759 5.781 5.407 129647.79 600519 2001-08-29 5.777 5.684 5.781 5.640 53252.75 600519 2001-08-30 5.668 5.796 5.860 5.624 48013.06 600519 2001-08-31 5.804 5.782 5.877 5.749 23231.48 600519 123#输出该股票所有收盘比开盘上涨3%以上的日期。#（收盘-开盘）/开盘 &gt; 0.03(df['close'] - df['open'])/df['open'] &gt; 0.03 date 2001-08-27 True 2001-08-28 True 2001-08-29 False 2001-08-30 False 2001-08-31 False ... 2020-01-09 False 2020-01-10 False 2020-01-13 False 2020-01-14 False 2020-01-15 False Length: 4388, dtype: bool123#测试#一组布尔值是可以作为df的行索引，不可作为列索引df.loc[[True,False,True]] 12#将布尔值作为了源数据df的行索引，可以取出True对应的行数据df.loc[(df['close'] - df['open'])/df['open'] &gt; 0.03] open close high low volume code date 2001-08-27 5.392 5.554 5.902 5.132 406318.00 600519 2001-08-28 5.467 5.759 5.781 5.407 129647.79 600519 2001-09-10 5.531 5.734 5.757 5.470 18878.89 600519 2001-12-21 5.421 5.604 5.620 5.421 8135.04 600519 2002-01-18 5.437 5.726 5.762 5.421 32262.08 600519 ... ... ... ... ... ... ... 2019-06-11 876.000 910.890 915.610 875.000 80106.00 600519 2019-06-20 932.500 975.000 975.500 932.200 67271.00 600519 2019-09-12 1066.000 1099.000 1109.980 1066.000 41211.00 600519 2019-09-18 1108.500 1148.900 1150.000 1108.180 69314.00 600519 1df.loc[(df['close'] - df['open'])/df['open'] &gt; 0.03].index DatetimeIndex([&apos;2001-08-27&apos;, &apos;2001-08-28&apos;, &apos;2001-09-10&apos;, &apos;2001-12-21&apos;, &apos;2002-01-18&apos;, &apos;2002-01-31&apos;, &apos;2003-01-14&apos;, &apos;2003-10-29&apos;, &apos;2004-01-05&apos;, &apos;2004-01-14&apos;, ... &apos;2019-03-01&apos;, &apos;2019-03-18&apos;, &apos;2019-04-10&apos;, &apos;2019-04-16&apos;, &apos;2019-05-10&apos;, &apos;2019-05-15&apos;, &apos;2019-06-11&apos;, &apos;2019-06-20&apos;, &apos;2019-09-12&apos;, &apos;2019-09-18&apos;], dtype=&apos;datetime64[ns]&apos;, name=&apos;date&apos;, length=303, freq=None) shift(1):将Series的数据整体向下移动一位 123#输出该股票所有开盘比前日收盘跌幅超过2%的日期#（开盘-前日收盘）/前日收盘 &lt; -0.02(df['open'] - df['close'].shift(1))/df['close'].shift(1) &lt; -0.02 date 2001-08-27 False 2001-08-28 False 2001-08-29 False 2001-08-30 False 2001-08-31 False ... 2020-01-06 False 2020-01-07 False 2020-01-08 False 2020-01-09 False 2020-01-10 False Length: 4385, dtype: bool12#将布尔值作为源数据的行索引df.loc[(df['open'] - df['close'].shift(1))/df['close'].shift(1) &lt; -0.02].index DatetimeIndex([&apos;2001-09-12&apos;, &apos;2002-06-26&apos;, &apos;2002-12-13&apos;, &apos;2004-07-01&apos;, &apos;2004-10-29&apos;, &apos;2006-08-21&apos;, &apos;2006-08-23&apos;, &apos;2007-01-25&apos;, &apos;2007-02-01&apos;, &apos;2007-02-06&apos;, &apos;2007-03-19&apos;, &apos;2007-05-21&apos;, &apos;2007-05-30&apos;, &apos;2007-06-05&apos;, &apos;2007-07-27&apos;, &apos;2007-09-05&apos;, &apos;2007-09-10&apos;, &apos;2008-03-13&apos;, &apos;2008-03-17&apos;, &apos;2008-03-25&apos;, &apos;2008-03-27&apos;, &apos;2008-04-22&apos;, &apos;2008-04-23&apos;, &apos;2008-04-29&apos;, &apos;2008-05-13&apos;, &apos;2008-06-10&apos;, &apos;2008-06-13&apos;, &apos;2008-06-24&apos;, &apos;2008-06-27&apos;, &apos;2008-08-11&apos;, &apos;2008-08-19&apos;, &apos;2008-09-23&apos;, &apos;2008-10-10&apos;, &apos;2008-10-15&apos;, &apos;2008-10-16&apos;, &apos;2008-10-20&apos;, &apos;2008-10-23&apos;, &apos;2008-10-27&apos;, &apos;2008-11-06&apos;, &apos;2008-11-12&apos;, &apos;2008-11-20&apos;, &apos;2008-11-21&apos;, &apos;2008-12-02&apos;, &apos;2009-02-27&apos;, &apos;2009-03-25&apos;, &apos;2009-08-13&apos;, &apos;2010-04-26&apos;, &apos;2010-04-30&apos;, &apos;2011-08-05&apos;, &apos;2012-03-27&apos;, &apos;2012-08-10&apos;, &apos;2012-11-22&apos;, &apos;2012-12-04&apos;, &apos;2012-12-24&apos;, &apos;2013-01-16&apos;, &apos;2013-01-25&apos;, &apos;2013-09-02&apos;, &apos;2014-04-25&apos;, &apos;2015-01-19&apos;, &apos;2015-05-25&apos;, &apos;2015-07-03&apos;, &apos;2015-07-08&apos;, &apos;2015-07-13&apos;, &apos;2015-08-24&apos;, &apos;2015-09-02&apos;, &apos;2015-09-15&apos;, &apos;2017-11-17&apos;, &apos;2018-02-06&apos;, &apos;2018-02-09&apos;, &apos;2018-03-23&apos;, &apos;2018-03-28&apos;, &apos;2018-07-11&apos;, &apos;2018-10-11&apos;, &apos;2018-10-24&apos;, &apos;2018-10-25&apos;, &apos;2018-10-29&apos;, &apos;2018-10-30&apos;, &apos;2019-05-06&apos;, &apos;2019-05-08&apos;, &apos;2019-10-16&apos;, &apos;2020-01-02&apos;], dtype=&apos;datetime64[ns]&apos;, name=&apos;date&apos;, freq=None) 假如我从2010年1月1日开始，每月第一个交易日买入1手股票，每年最后一个交易日卖出所有股票，到今天为止，我的收益如何？ 分析：设定买卖股票是基于股票的开盘价进行买卖的 买入： 一个完整的年需要买入12次股票共计1200只 将每月第一个交易日对应的行数据取出，从行数据中提取出购买的单价（开盘价） 卖出： 一个完整的年需要卖出1次股票共计1200只 将每年最后一个交易日的行数据取出，从行数据中提取出售卖的单价（开盘价） 特殊情况： 在2020年只可以买入100只股票但是无法卖出。但是剩余股票的价值也需要计算到总收益中 1data = df['2010':'2020'] #data表示的是2010-2020年之间的历史交易数据 123#数据的重新取样resampledata_monthly = data.resample('M').first()data_monthly.head()#存储就是每月第一个叫日期对应的行数据 open close high low volume code date 2010-01-31 109.760 108.446 109.760 108.044 44304.88 600519 2010-02-28 107.769 107.776 108.216 106.576 29655.94 600519 2010-03-31 106.219 106.085 106.857 105.925 21734.74 600519 2010-04-30 101.324 102.141 102.422 101.311 23980.83 600519 2010-05-31 81.676 82.091 82.678 80.974 23975.16 600519 123#计算2010-2020期间买入股票的花费cost_monry = data_monthly['open'].sum()*100cost_monry 3911706.11234#买入股票收入多少钱data_yearly = data.resample('A').last()[:-1]recv_money = data_yearly['open'].sum() * 1200recv_money 4368184.812#剩余1手股票的实际价值(最后一天的开盘价作为剩余股票价值的单价)last_monry = 100 * data['open'][-1] 12#总收益last_monry+recv_money-cost_monry 567378.6999999997","link":"/2020/01/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-pandas%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"},{"title":"双均线策略","text":"需求：双均线策略制定 使用tushare包获取某股票的历史行情数据 计算该股票历史数据的5日均线和30日均线 什么是均线？ 对于每一个交易日，都可以计算出前N天的移动平均值，然后把这些移动平均值连起来，成为一条线，就叫做N日移动平均线。移动平均线常用线有5天、10天、30天、60天、120天和240天的指标。 5天和10天的是短线操作的参照指标，称做日均线指标； 30天和60天的是中期均线指标，称做季均线指标； 120天和240天的是长期均线指标，称做年均线指标。 均线计算方法：MA=（C1+C2+C3+…+Cn)/N C:某日收盘价 N:移动平均周期（天数） 12345import numpy as npimport pandas as pdfrom pandas import Series,DataFrameimport tushare as ts#财经数据接口包import matplotlib.pyplot as plt 12df = ts.get_k_data('600519',start='2000-01-01')df.to_csv('./maotai.csv') 123456df = pd.read_csv('./maotai.csv')df.drop(labels='Unnamed: 0',axis=1,inplace=True)#将date列的数据转成时间序列且将其作为源数据的行索引df['date'] = pd.to_datetime(df['date'])df.set_index('date',inplace=True)df.head() open close high low volume code date 2001-08-27 5.392 5.554 5.902 5.132 406318.00 600519 2001-08-28 5.467 5.759 5.781 5.407 129647.79 600519 2001-08-29 5.777 5.684 5.781 5.640 53252.75 600519 2001-08-30 5.668 5.796 5.860 5.624 48013.06 600519 2001-08-31 5.804 5.782 5.877 5.749 23231.48 600519 123#ma表示的是均线ma5 = df['close'].rolling(5).mean()ma30 = df['close'].rolling(30).mean() 1234#将ma5和ma30汇总到源数据中df['ma5'] = ma5df['ma30'] = ma30df open close high low volume code ma5 ma30 date 2001-08-27 5.392 5.554 5.902 5.132 406318.00 600519 NaN NaN 2001-08-28 5.467 5.759 5.781 5.407 129647.79 600519 NaN NaN 2001-08-29 5.777 5.684 5.781 5.640 53252.75 600519 NaN NaN 2001-08-30 5.668 5.796 5.860 5.624 48013.06 600519 NaN NaN 2001-08-31 5.804 5.782 5.877 5.749 23231.48 600519 5.715 NaN ... ... ... ... ... ... ... ... ... 2020-01-09 1094.000 1102.700 1105.390 1090.000 37405.00 600519 1088.384 1140.647667 2020-01-10 1109.000 1112.500 1115.990 1102.500 35975.00 600519 1095.172 1138.537667 2020-01-13 1112.500 1124.270 1129.200 1112.000 38515.00 600519 1104.428 1138.380000 2020-01-14 1124.200 1107.400 1124.890 1103.000 35144.00 600519 1107.002 1137.526667 2020-01-15 1109.010 1112.130 1121.600 1105.000 26029.00 600519 1111.800 1137.331000 可视化历史数据的收盘价和两条均线 12plt.plot(ma5[50:100],c='red')plt.plot(ma30[50:100],c='blue') [&lt;matplotlib.lines.Line2D at 0x1fc5d722710&gt;] 分析输出所有金叉日期和死叉日期 股票分析技术中的金叉和死叉，可以简单解释为： 分析指标中的两根线，一根为短时间内的指标线，另一根为较长时间的指标线。 如果短时间的指标线方向拐头向上，并且穿过了较长时间的指标线，这种状态叫“金叉”； 如果短时间的指标线方向拐头向下，并且穿过了较长时间的指标线，这种状态叫“死叉”； 一般情况下，出现金叉后，操作趋向买入；死叉则趋向卖出。当然，金叉和死叉只是分析指标之一，要和其他很多指标配合使用，才能增加操作的准确性。 如果我从假如我从2010年1月1日开始，初始资金为100000元，金叉尽量买入，死叉全部卖出，则到今天为止，我的炒股收益率如何？ 12df = df['2010':'2020']df open close high low volume code ma5 ma30 date 2010-01-04 109.760 108.446 109.760 108.044 44304.88 600519 108.5402 109.306267 2010-01-05 109.116 108.127 109.441 107.846 31513.18 600519 108.4178 109.256500 2010-01-06 107.840 106.417 108.165 106.129 39889.03 600519 107.8512 109.191000 2010-01-07 106.417 104.477 106.691 103.302 48825.55 600519 107.1672 108.971067 2010-01-08 104.655 103.379 104.655 102.167 36702.09 600519 106.1692 108.833000 ... ... ... ... ... ... ... ... ... 2020-01-09 1094.000 1102.700 1105.390 1090.000 37405.00 600519 1088.3840 1140.647667 2020-01-10 1109.000 1112.500 1115.990 1102.500 35975.00 600519 1095.1720 1138.537667 2020-01-13 1112.500 1124.270 1129.200 1112.000 38515.00 600519 1104.4280 1138.380000 2020-01-14 1124.200 1107.400 1124.890 1103.000 35144.00 600519 1107.0020 1137.526667 2020-01-15 1109.010 1112.130 1121.600 1105.000 26029.00 600519 1111.8000 1137.331000 12sr1 = df['ma5'] &lt; df['ma30']sr2 = df['ma5'] &gt;= df['ma30'] 让sr1和sr2.shift(1)进行与操作或者或操作，返回的结果定位到金叉和死叉 12df.loc[sr1 &amp; sr2.shift(1)] #死叉对应的行数据death_dates = df.loc[sr1 &amp; sr2.shift(1)].index 12df.loc[~(sr1 | sr2.shift(1))]#金叉对应的行数据golden_dates = df.loc[~(sr1 | sr2.shift(1))].index 1golden_dates DatetimeIndex([&apos;2010-01-20&apos;, &apos;2010-02-03&apos;, &apos;2010-06-04&apos;, &apos;2010-07-19&apos;, &apos;2010-10-22&apos;, &apos;2010-11-10&apos;, &apos;2011-02-11&apos;, &apos;2011-03-14&apos;, &apos;2011-04-28&apos;, &apos;2011-10-25&apos;, &apos;2012-02-10&apos;, &apos;2012-07-25&apos;, &apos;2012-08-09&apos;, &apos;2012-09-12&apos;, &apos;2012-09-27&apos;, &apos;2012-12-21&apos;, &apos;2013-01-10&apos;, &apos;2013-03-12&apos;, &apos;2013-04-17&apos;, &apos;2013-07-03&apos;, &apos;2013-10-22&apos;, &apos;2013-11-11&apos;, &apos;2013-11-28&apos;, &apos;2014-01-23&apos;, &apos;2014-04-03&apos;, &apos;2014-06-23&apos;, &apos;2014-09-04&apos;, &apos;2014-09-29&apos;, &apos;2014-11-20&apos;, &apos;2014-11-28&apos;, &apos;2015-02-13&apos;, &apos;2015-07-15&apos;, &apos;2015-09-16&apos;, &apos;2015-10-09&apos;, &apos;2015-12-03&apos;, &apos;2015-12-21&apos;, &apos;2016-02-22&apos;, &apos;2016-08-11&apos;, &apos;2016-10-13&apos;, &apos;2016-11-25&apos;, &apos;2017-07-24&apos;, &apos;2017-09-18&apos;, &apos;2017-12-15&apos;, &apos;2018-03-16&apos;, &apos;2018-05-09&apos;, &apos;2018-07-18&apos;, &apos;2018-07-25&apos;, &apos;2018-09-20&apos;, &apos;2018-12-04&apos;, &apos;2019-01-03&apos;, &apos;2019-06-14&apos;, &apos;2019-08-13&apos;, &apos;2020-01-02&apos;], dtype=&apos;datetime64[ns]&apos;, name=&apos;date&apos;, freq=None)12345678910111213141516171819202122232425#基于金叉和死叉买卖股票计算收益first_money = 100000money = first_moneyhold = 0 #持有股票的数量（股）s1 = Series(1,index=golden_dates)#1标识金叉日期s2 = Series(0,index=death_dates)#0表示死叉日期s = s1.append(s2) #存储的是所有的金叉和死叉日期s = s.sort_index() #根据索引排序for i in s.index: #开盘价作为买卖的单价 price = df.loc[i]['open'] if s[i] == 1:#金叉：买入 hand_cost = 100 * price#1手股票花费的钱数 hand_count = money // hand_cost #最多买入了多少手股票 hold = hand_count * 100 #买入的多少只股票 money -= hold*price else: money += hold * price hold = 0 #如果最后一天为金叉，最后一天买入股票，没有卖出。剩余的股票也要计算到总收益中last_money = hold * df['open'][-1]print(money + last_money - first_money) 1501254.9999999995","link":"/2020/01/11/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E5%8F%8C%E5%9D%87%E7%BA%BF%E7%AD%96%E7%95%A5/"},{"title":"数据分析","text":"什么是数据分析 是把隐藏在一些看似杂乱无章的数据背后的信息提炼出来，总结出所研究对象的内在规律 数据分析是用适当的方法对收集来的大量数据进行分析，帮助人们做出判断，以便采取适当的行动 商品采购量的多少 总部向各个地区代理的发货量 …… 数据分析实现流程 提出问题 准备数据 分析数据 获得结论 成果可视化 数据分析三剑客 numpy pandas matplotlib numpy模块：一维或者是多维的数组（低版本的列表） NumPy(Numerical Python) 是 Python 语言中做科学计算的基础库。重在于数值计算，也是大部分Python科学计算库的基础，多用于在大型、多维数组上执行的数值运算。 numpy的创建 使用np.array()创建 使用plt创建 使用np的routines函数创建 使用array()创建一个一维数组 123import numpy as nparr = np.array([1,2,3,4,5,6])arr array([1, 2, 3, 4, 5, 6]) 使用array()创建一个多维数组 1np.array([[1,2,3,4],[5,6,7,8],[9,9,9,9]]) array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 9, 9, 9]]) 数组和列表的区别是什么？ 数据中存储的数组元素的数据类型必须是统一 数据类型是有优先级： str&gt;float&gt;int 12arr = np.array([1,2.2,3,4,5,6])arr array([1. , 2.2, 3. , 4. , 5. , 6. ]) 将外部的一张图片读取加载到numpy数组中，然后尝试改变数组元素的数值查看对原始图片的影响 123import matplotlib.pyplot as pltimg_arr = plt.imread('./assets/1.jpg')plt.imshow(img_arr) &lt;matplotlib.image.AxesImage at 0x16e9faebb70&gt; 1plt.imshow(img_arr-100) &lt;matplotlib.image.AxesImage at 0x16eb3240dd8&gt; zeros() ones() linespace() arange() random系列 1np.zeros((3,4)) array([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]])1np.linspace(0,100,num=20) array([ 0. , 5.26315789, 10.52631579, 15.78947368, 21.05263158, 26.31578947, 31.57894737, 36.84210526, 42.10526316, 47.36842105, 52.63157895, 57.89473684, 63.15789474, 68.42105263, 73.68421053, 78.94736842, 84.21052632, 89.47368421, 94.73684211, 100. ])1np.arange(0,100,step=3) array([ 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99])1np.random.randint(0,100,size=(5,6)) array([[71, 76, 47, 11, 7, 6], [47, 89, 70, 44, 41, 96], [58, 42, 36, 53, 49, 55], [13, 32, 64, 58, 15, 7], [78, 56, 40, 71, 45, 63]])1np.random.random((3,4)) array([[0.24913375, 0.91988476, 0.36386714, 0.58404557], [0.15544885, 0.73892461, 0.82189615, 0.80368295], [0.07230386, 0.45535116, 0.75370029, 0.03377829]]) 随机性： 随机因子：x(时间) 123#固定随机性np.random.seed(10)np.random.randint(0,100,size=(5,6)) array([[ 9, 15, 64, 28, 89, 93], [29, 8, 73, 0, 40, 36], [16, 11, 54, 88, 62, 33], [72, 78, 49, 51, 54, 77], [69, 13, 25, 13, 92, 86]])numpy的常用属性 shape ndim size dtype 12345img_arr.shapeimg_arr.ndimimg_arr.sizeimg_arr.dtypetype(img_arr) numpy.ndarray1arr = np.array([1,2,3],dtype='uint8') numpy的数据类型 array(dtype=?):可以设定数据类型 arr.dtype = ‘?’:可以修改数据类型 1arr = np.array([1,2,3]) 1arr.dtype = 'int32' numpy的索引和切片操作（重点） 索引操作和列表同理 12arr = np.random.randint(0,100,size=(6,8))arr array([[30, 30, 89, 12, 65, 31, 57, 36], [27, 18, 93, 77, 22, 23, 94, 11], [28, 74, 88, 9, 15, 18, 80, 71], [88, 11, 17, 46, 7, 75, 28, 33], [84, 96, 88, 44, 5, 4, 71, 88], [88, 50, 54, 34, 15, 77, 88, 15]])1arr[1] array([27, 18, 93, 77, 22, 23, 94, 11]) 切片操作 切出前两列数据 切出前两行数据 切出前两行的前两列的数据 数组数据翻转 练习：将一张图片上下左右进行翻转操作 练习：将图片进行指定区域的裁剪 1arr.shape (6, 8)12#切出前两行arr[0:2] array([[30, 30, 89, 12, 65, 31, 57, 36], [27, 18, 93, 77, 22, 23, 94, 11]])12#切出前两列arr[hang,lie]arr[:,0:2] array([[30, 30], [27, 18], [28, 74], [88, 11], [84, 96], [88, 50]])12#切出前两行的前两列的数据arr[0:2,0:2] array([[30, 30], [27, 18]])12#数组数据翻转plt.imshow(img_arr) &lt;matplotlib.image.AxesImage at 0x16eb30833c8&gt; 1img_arr.shape #前两个维度表示的是像素，最后一个维度表示颜色 (426, 640, 3)12#将图片进行上下翻转plt.imshow(img_arr[::-1,:,:]) &lt;matplotlib.image.AxesImage at 0x16eb30de828&gt; 1plt.imshow(img_arr[:,::-1,:]) &lt;matplotlib.image.AxesImage at 0x16eb313b8d0&gt; 1plt.imshow(img_arr[::-1,::-1,::-1]) &lt;matplotlib.image.AxesImage at 0x16eb3198a58&gt; 12#裁剪plt.imshow(img_arr) &lt;matplotlib.image.AxesImage at 0x16eb31f8898&gt; 1plt.imshow(img_arr[50:450,300:750,:]) &lt;matplotlib.image.AxesImage at 0x16eb5164470&gt; 切片汇总： 切行：arr[index1:index3] 切列：arr[行切片,列切片] 翻转：arr[::-1] 变形reshape 变形前和变形后对应的数组元素个数是一致 12arr = np.array([1,2,3,4,5,6])arr array([1, 2, 3, 4, 5, 6])12#将一维数组变形成二维arr.reshape((2,3)) array([[1, 2, 3], [4, 5, 6]])1arr.reshape((-1,2)) array([[1, 2], [3, 4], [5, 6]])级联操作：concatenate 是对numpy数组进行横向或者纵向的拼接 axis轴向的理解 0:列 1：行 12arr1 = np.array([[1,2,3],[4,5,6]])arr1 array([[1, 2, 3], [4, 5, 6]])1np.concatenate((arr1,arr1),axis=1) array([[1, 2, 3, 1, 2, 3], [4, 5, 6, 4, 5, 6]])12arr2 = np.array([[1,2,3,3],[4,5,6,6]])arr2 array([[1, 2, 3, 3], [4, 5, 6, 6]]) 匹配级联 级联的多个数组的形状是一样 不匹配级联 级联的多个数组的形状是不一样（维度必须一样） 多个数组的行数一样进行行级联 多个数组的列数一样进行列级联 12#讲arr1和arr2进行级联np.concatenate((arr1,arr2),axis=1) array([[1, 2, 3, 1, 2, 3, 3], [4, 5, 6, 4, 5, 6, 6]])常用的聚合操作 sum,max,min,mean 12arr = np.random.randint(0,10,size=(4,5))arr array([[6, 6, 5, 6, 0], [0, 6, 9, 1, 8], [9, 1, 2, 8, 9], [9, 5, 0, 2, 7]])1arr.sum(axis=1) array([23, 24, 29, 23])常用的数学函数 NumPy 提供了标准的三角函数：sin()、cos()、tan() numpy.around(a,decimals) 函数返回指定数字的四舍五入值。 参数说明： a: 数组 decimals: 舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置 1np.sin(arr) array([[-0.2794155 , -0.2794155 , -0.95892427, -0.2794155 , 0. ], [ 0. , -0.2794155 , 0.41211849, 0.84147098, 0.98935825], [ 0.41211849, 0.84147098, 0.90929743, 0.98935825, 0.41211849], [ 0.41211849, -0.95892427, 0. , 0.90929743, 0.6569866 ]])12arr = np.random.random(size=(3,4))arr array([[0.07961309, 0.30545992, 0.33071931, 0.7738303 ], [0.03995921, 0.42949218, 0.31492687, 0.63649114], [0.34634715, 0.04309736, 0.87991517, 0.76324059]])1np.around(arr,decimals=2) array([[0.08, 0.31, 0.33, 0.77], [0.04, 0.43, 0.31, 0.64], [0.35, 0.04, 0.88, 0.76]])常用的统计函数 numpy.amin() 和 numpy.amax()，用于计算数组中的元素沿指定轴的最小、最大值。 numpy.ptp():计算数组中元素最大值与最小值的差（最大值 - 最小值）。 numpy.median() 函数用于计算数组 a 中元素的中位数（中值） 标准差std():标准差是一组数据平均值分散程度的一种度量。 公式：std = sqrt(mean((x - x.mean())**2)) 如果数组是 [1，2，3，4]，则其平均值为 2.5。 因此，差的平方是 [2.25,0.25,0.25,2.25]，并且其平均值的平方根除以 4，即 sqrt(5/4) ，结果为 1.1180339887498949。 方差var()：统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即 mean((x - x.mean())** 2)。换句话说，标准差是方差的平方根。 12arr = np.random.randint(0,20,size=(5,3))arr array([[12, 18, 17], [17, 16, 0], [ 5, 9, 0], [ 6, 0, 2], [ 3, 3, 18]])1np.amin(arr,axis=0) array([3, 0, 0])1np.ptp(arr,axis=0) array([14, 18, 18])1np.median(arr,axis=0) array([6., 9., 2.])1np.std(arr,axis=0) array([5.16139516, 7.02566723, 8.28492607])1np.var(arr,axis=0) array([26.64, 49.36, 68.64])矩阵相关 NumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象。一个 的矩阵是一个由行（row）列（column）元素排列成的矩形阵列。 matlib.empty() 函数返回一个新的矩阵，语法格式为：numpy.matlib.empty(shape, dtype)，填充为随机数据 参数介绍： shape: 定义新矩阵形状的整数或整数元组 Dtype: 可选，数据类型 12import numpy.matlib as matlibmatlib.empty(shape=(4,5)) matrix([[-0.2794155 , -0.2794155 , -0.95892427, -0.2794155 , 0. ], [ 0. , -0.2794155 , 0.41211849, 0.84147098, 0.98935825], [ 0.41211849, 0.84147098, 0.90929743, 0.98935825, 0.41211849], [ 0.41211849, -0.95892427, 0. , 0.90929743, 0.6569866 ]]) numpy.matlib.zeros()，numpy.matlib.ones()返回填充为0或者1的矩阵 12 numpy.matlib.eye() 函数返回一个矩阵，对角线元素为 1，其他位置为零。 numpy.matlib.eye(n, M,k, dtype) n: 返回矩阵的行数 M: 返回矩阵的列数，默认为 n k: 对角线的索引 dtype: 数据类型 1matlib.eye(5,5,1) matrix([[0., 1., 0., 0., 0.], [0., 0., 1., 0., 0.], [0., 0., 0., 1., 0.], [0., 0., 0., 0., 1.], [0., 0., 0., 0., 0.]]) numpy.matlib.identity() 函数返回给定大小的单位矩阵。单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1，除此以外全都为 0。 1matlib.identity(6) matrix([[1., 0., 0., 0., 0., 0.], [0., 1., 0., 0., 0., 0.], [0., 0., 1., 0., 0., 0.], [0., 0., 0., 1., 0., 0.], [0., 0., 0., 0., 1., 0.], [0., 0., 0., 0., 0., 1.]]) 转置矩阵 .T 12arr = matlib.identity(6)arr matrix([[1., 0., 0., 0., 0., 0.], [0., 1., 0., 0., 0., 0.], [0., 0., 1., 0., 0., 0.], [0., 0., 0., 1., 0., 0.], [0., 0., 0., 0., 1., 0.], [0., 0., 0., 0., 0., 1.]])12a = np.array([[1,2,3],[4,5,6]])a array([[1, 2, 3], [4, 5, 6]])1a.T array([[1, 4], [2, 5], [3, 6]]) 矩阵相乘 numpy.dot(a, b, out=None) a : ndarray 数组 b : ndarray 数组 第一个矩阵第一行的每个数字（2和1），各自乘以第二个矩阵第一列对应位置的数字（1和1），然后将乘积相加（ 2 x 1 + 1 x 1），得到结果矩阵左上角的那个值3。也就是说，结果矩阵第m行与第n列交叉位置的那个值，等于第一个矩阵第m行与第二个矩阵第n列，对应位置的每个值的乘积之和。 线性代数基于矩阵的推导： https://www.cnblogs.com/alantu2018/p/8528299.html 123arr_1 = np.array([[1,2,3],[4,5,6]]) #2行3列arr_2 = np.array([[1,2,3],[4,5,6]]) arr_2 = arr_2.T 1arr_1 array([[1, 2, 3], [4, 5, 6]])1arr_2 array([[1, 4], [2, 5], [3, 6]])1np.dot(arr_1,arr_2) array([[14, 32], [32, 77]])","link":"/2020/01/08/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-1-numpy%E6%A8%A1%E5%9D%97/"}],"tags":[{"name":"数据分析","slug":"数据分析","link":"/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"categories":[{"name":"数据分析","slug":"数据分析","link":"/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}]}